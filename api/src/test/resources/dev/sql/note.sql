-- MySQL dump 10.16  Distrib 10.1.32-MariaDB, for Linux (x86_64)
--
-- Host: localhost    Database: api_dev
-- ------------------------------------------------------
-- Server version	10.1.32-MariaDB

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `note`
--

DROP TABLE IF EXISTS `note`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `note` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '笔记Id',
  `user_id` bigint(20) unsigned NOT NULL COMMENT '创建用户Id',
  `title` varchar(128) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL COMMENT '标题',
  `description` text NOT NULL COMMENT '内容',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `ix_note_title` (`title`),
  CONSTRAINT `note_fk_1` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COMMENT='用户笔记表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `note`
--

LOCK TABLES `note` WRITE;
/*!40000 ALTER TABLE `note` DISABLE KEYS */;
INSERT INTO `note` VALUES (1,2,'HashTable简略分析','<p><strong>源码</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">            <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际上 Entry 是一个单向链表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>{</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表的"key-value键值对"都是存储在 Entry 数组中的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Hashtable.Entry&lt;?, ?&gt;[] table;</span><br><span class="line">    <span class="comment">// Hashtable 中保存的键值对的实际数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;  </span><br><span class="line">    <span class="comment">// 阈值，用于判断是否需要调整 Hashtable 的容量（threshold = 容量*加载因子）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">// 加载因子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">    <span class="comment">// Hashtable 被改变的次数，实现fail-fast机制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> entry)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.modCount++;</span><br><span class="line">        Hashtable.Entry[] table = <span class="keyword">this</span>.table;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果容器中的元素数量已经达到阀值，则进行扩容操作</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.count &gt;= <span class="keyword">this</span>.threshold) {</span><br><span class="line">            <span class="keyword">this</span>.rehash();</span><br><span class="line">            table = <span class="keyword">this</span>.table;</span><br><span class="line">            hash = key.hashCode();</span><br><span class="line">            entry = (hash &amp; <span class="number">0x7FFFFFFF</span>) % table.length;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在索引位置处插入一个新的节点</span></span><br><span class="line">        Hashtable.Entry e = table[entry];</span><br><span class="line">        table[entry] = <span class="keyword">new</span> Hashtable.Entry(hash, key, value, e);</span><br><span class="line">        <span class="comment">// 容器中元素+1</span></span><br><span class="line">        <span class="keyword">this</span>.count++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{</span><br><span class="line">        <span class="comment">// 确保 value 不为 null</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">/*  </span></span><br><span class="line"><span class="comment">            * 确保 key 在 table[] 是不重复的  </span></span><br><span class="line"><span class="comment">            * 处理过程：  </span></span><br><span class="line"><span class="comment">            * 1、计算 key 的 hash 值，确认在 table[] 中的索引位置  </span></span><br><span class="line"><span class="comment">            * 2、迭代 index 索引位置，如果该位置处的链表中存在一个一样的 key，则替换其 value，返回旧值  </span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            Hashtable.Entry[] table = <span class="keyword">this</span>.table;</span><br><span class="line">            <span class="comment">// key 的 hash 值，而 null 没有 hashCode，所以 key 不能为 null</span></span><br><span class="line">            <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">            <span class="comment">// 确认该 key 的索引位置</span></span><br><span class="line">            <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % table.length;</span><br><span class="line">            <span class="comment">// 迭代，寻找该 key，替换</span></span><br><span class="line">            <span class="keyword">for</span>(Hashtable.Entry e = table[index]; e != <span class="keyword">null</span>; e = e.next) {</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; e.key.equals(key)) {</span><br><span class="line">                    Object old = e.value;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span> old;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.addEntry(hash, key, value, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>{</span><br><span class="line">        Hashtable.Entry[] table = <span class="keyword">this</span>.table;</span><br><span class="line">        <span class="comment">// 先获得索引值</span></span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % table.length;</span><br><span class="line">        <span class="comment">// 然后遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Hashtable.Entry e = table[index]; e != <span class="keyword">null</span>; e = e.next) {</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; e.key.equals(key)) {</span><br><span class="line">                <span class="comment">// 最后返回</span></span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>继承关系</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object  </span><br><span class="line">  ↳ java.util.Dictionary&lt;K, V&gt;  </span><br><span class="line">      ↳ java.util.Hashtable&lt;K, V&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>特点</strong></p><ol><li>Hashtable 是一个散列表，它存储的内容是键值对（key-value）映射。</li><li>key、value 都不可以为 null。</li><li>Hashtable 继承于 Dictionary，实现了 Map、Cloneable、java.io.Serializable 接口。</li><li>Hashtable 的方法都是同步（synchronized）的，即其是线程安全的。</li></ol><p><strong>构造函数</strong></p><p>Hashtable 提供了4个构造函数：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 指定“容量大小”的构造函数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 指定“容量大小”和“加载因子”的构造函数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 包含“子Map”的构造函数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(Map&lt;? extends K, ? extends V&gt; map)</span></span></span><br></pre></td></tr></tbody></table></figure><p>上面的四个构造方法中，第三个最重要，指定初始化容量和构造因子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.modCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 验证初始容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span> + initialCapacity);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证加载因子</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0.0F</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load: "</span>+ loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>)</span><br><span class="line">        initialCapacity = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 table，获得大小为 initialCapacity 的 table 数组    </span></span><br><span class="line">    <span class="keyword">this</span>.table = <span class="keyword">new</span> Hashtable.Entry[initialCapacity];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算阀值</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = (<span class="keyword">int</span>) Math.min((<span class="keyword">float</span>) initialCapacity * loadFactor, <span class="keyword">this</span>.MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>Hashtable 和 HashMap 区别</strong></p><blockquote><p>Dictionary 是什么？<br>它可以将任何键映射到相应值的类的抽象类。</p><p>AbstractMap 是什么？<br>它是基于 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作。</p></blockquote><ol><li><p>基类不同：HashTable 基于 Dictionary 类，而 HashMap 基于 AbstractMap。</p></li><li><p>null：HashTable 中的 key 和 value 都不允许为 null，但 HashMap 允许存在一个 key 为 null 和任意个 value 为 null 的键值对。</p></li><li><p>线程安全：Hashtable 线程安全，HashMap 线程不安全。</p></li><li><p>遍历不同：HashMap 仅支持 Iterator 的遍历方式，Hashtable 支持 Iterator 和 Enumeration 两种遍历方式。</p></li></ol>','2018-05-01 12:00:00');
INSERT INTO `note` VALUES (2,2,'《算法导论》笔记2-8','<h1 id="线性时间排序"><a href="#线性时间排序" class="headerlink" title="线性时间排序"></a>线性时间排序</h1><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序假设 n 个输入元素中的每一个都是在 0 到 max 区间内的一个整数。（max 是数组里最大的数字）</p><p>基本思想：对每个输入元素 x，确定小于 x 的元素个数。利用这一信息，就可以直接把 x 放到它的输出数组中的位置了。例如如果有 17 个元素小于 x，则 x 就应该在第 18 个输出位置上。当有几个元素相同时，这一方案就要稍作修改，因为不能把它们放在同一输出位置。</p><p>假设输入数组是 A[0 … n]，那么我们还需要两个数组：B[0 … n] 输出数组，C[0 … max] 临时数组。</p><p>伪代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">counting_sort(A, B, max)</span><br><span class="line">	C = [max]</span><br><span class="line">	<span class="comment"># 初始化</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, max)</span><br><span class="line">		C[i] = <span class="number">0</span></span><br><span class="line">	<span class="comment"># 计数</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, A.length)</span><br><span class="line">		C[A[i]]++</span><br><span class="line">	<span class="comment"># 统计有多少元素 &lt;= i</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, max)</span><br><span class="line">		C[i] += C[i - <span class="number">1</span>]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, A.length, <span class="number">-1</span>)</span><br><span class="line">		B[C[A[i]]] = A[i]</span><br><span class="line">		C[A[i]]--</span><br></pre></td></tr></tbody></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>这里通过实例说： 设有一个初始序列为 A = {50, 123, 543, 187, 49, 30, 0, 2, 11, 100}。<br>为方便说明将这些数字补齐成这样：{050, 123, 543, 187, 049, 030, 000, 002, 011, 100}。</p><ol><li>按个位排序：{050, 030, 000, 100, 011, 002, 123, 543, 187, 049}。（50、30、0、100 的个位都是 0）</li><li>按十位排序：{000, 100, 002, 011, 123, 030, 543, 049, 050, 187}。（个位排序后顺序判断）</li><li>按百位排序：{000, 002, 011, 030, 049, 050, 100, 123, 187, 543}。（十位排序后顺序判断）</li></ol><p>最后得到由小到大的序列：{0, 2, 11, 30, 49, 50, 100, 123, 187, 543}。</p><p>例如，对 {2010-3-4, 2001-4-30, 2008-8-1, 2001-2-28, 1998-3-8} 按日期从小到大排序。</p><ol><li>对日按照上面的个十位排序：{2008-8-1, 2010-3-4, 1998-3-8, 2001-2-28, 2001-4-30}。</li><li>对月按照个十位排序：{2001-2-28, 2010-3-4, 1998-3-8, 2001-4-30, 2008-8-1}。</li><li>对年按照个十百千位排序：{1998-3-8, 2001-2-28, 2001-4-30, 2008-8-1, 2010-3-4}。</li></ol><p>伪代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">radix_sort(A, highestBit)</span><br><span class="line">	<span class="comment"># 从最低位到最高位</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, highestBit)</span><br><span class="line">		<span class="comment"># 使用稳定的排序算法对数组 A 排序，比如计数排序</span></span><br><span class="line">		counting_sort(A, B, max)</span><br></pre></td></tr></tbody></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序假设输入的数据服从均匀分布，平均情况下它的时间代价为 O(n)。</p><p>伪代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bucket_sort(A)</span><br><span class="line">	n = A.length</span><br><span class="line">	<span class="comment"># B 是存放链表（桶）的数组</span></span><br><span class="line">	B = new [n - <span class="number">1</span>]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n)</span><br><span class="line">		<span class="comment"># 把 A[i] 插到 B 对应的桶中</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">		<span class="comment"># 对 B 中的每一个桶（即B[i]）都进行排序，比如插入排序</span></span><br><span class="line">		<span class="comment"># 桶里存了若干元素，也就相当于数组</span></span><br><span class="line">		insert_sort(B[i])</span><br><span class="line">	<span class="comment"># 最后把第一个桶到最后一个桶中的所有元素合并起来</span></span><br></pre></td></tr></tbody></table></figure>','2018-05-01 09:15:00');
INSERT INTO `note` VALUES (3,2,'三个常见博弈游戏','<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过数论或者自然数性质完美解决的三个常见博弈游戏：</p><table><thead><tr><th style="text-align:center">博弈</th><th style="text-align:center">解决方法</th></tr></thead><tbody><tr><td style="text-align:center">Bash Game</td><td style="text-align:center">同余理论</td></tr><tr><td style="text-align:center">Nim Game</td><td style="text-align:center">异或理论</td></tr><tr><td style="text-align:center">Wythoff Game</td><td style="text-align:center">黄金分割</td></tr></tbody></table><h1 id="Bash-Game"><a href="#Bash-Game" class="headerlink" title="Bash Game"></a>Bash Game</h1><p>描述：<br>一堆 n 个物品，两人轮流取，每次取 1 至 m 个，最后取完者胜。</p><p>以先手为例，分析：</p><ol><li>面对 [1…m] 个局面，必胜。</li><li>面对 m + 1 个局面，必败。</li><li>如果可以使对手面临必败局面，那么必胜。</li><li>如果不能使对手面临必败局面，那么必败。</li></ol><p>进一步：<br>基础：1， 2，……， m 是必胜局面， m + 1是必败局面。<br>递推：m + 2，m + 3，……，2m + 1 是必胜局面，2m + 2是必败局面。</p><p>k(m + 1) 是必败局面，应该允许 k = 0，因为 0 显然也是必败局面。<br>在必败局和必胜局中，胜方的策略是：拿掉部分物品，使对方面临 k(m + 1) 的局面。</p><p>即：n % (m + 1) == 0 时，先手必败。</p><p>比如，有 10 个物品，每次只能取 1 到 5 个，则先手方必胜：先手方拿 4 个，对手无论拿多少个，先手方下次总能拿完。</p><p>从另一个角度思考该问题：如果物品数量随机，那么先手方胜利的概率是 m/(m + 1)，后手方胜利的概率是 1/(m + 1)。</p><h1 id="Nim-Game"><a href="#Nim-Game" class="headerlink" title="Nim Game"></a>Nim Game</h1><p>描述：<br>m 堆 n 个物品，两人轮流取，每次取某堆中不少于 1 个，最后取完者胜。</p><p>分析：</p><ol><li>所有物品数目二进制异或不为 0，则先手必胜。</li><li>所有物品数目二进制异或为 0，则后手必胜。</li></ol><p>从另一个角度思考该问题：如果物品数量随机，那么每个数目的每一位上 1 或 0 概率相同：</p><ul><li>如果有奇数个堆，那么 1 的个数为偶数或者奇数的概率相同，</li><li>如果有偶数个堆，那么 1 的个数为偶数的概率略大 1/(m + 1)，<br>也就是说异或结果的每一位为 0 或 1 的概率几乎差不多，而先手必败要求异或结果每一位都为 0，其实败的概率很小。</li></ul><h1 id="Wythoff-Game"><a href="#Wythoff-Game" class="headerlink" title="Wythoff Game"></a>Wythoff Game</h1><p>描述：<br>2 堆（ak, bk）(ak &lt;= bk)物品，两人轮流取，每次从 1 堆中取 k 个或者从 2 堆中同时取 k 个，最后面对 (0, 0) 局面的败（设ak &lt;= bk是为了忽略顺序的影响）。</p><p>以先手为例，分析：</p><ol><li>面对 (0,0) 局面必败。</li><li>面对 (1,1)(2,2)…(n,n)、(0,1)(0,2)…(0,n) 局面必胜。</li><li>如果可以使对手面临必败局面，那么必胜。</li><li>如果不能使对手面临必败局面，那么必败。</li></ol><p>进一步：<br>基础：(0,0) 是必败局面；(0,1)(0,2)…(0,n) 是必胜局面。<br>递推：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(1,2) 是必败局面；	(1,1)</span><br><span class="line">					(1,3)(1,4)...(1,n)</span><br><span class="line">					(2,2)(2,3)...(2,n) 是必胜局面，</span><br><span class="line">(3,5) 是必败局面；	(3,3)(3,4)</span><br><span class="line">					(3,6)(3,7)...(3,n)</span><br><span class="line">					(5,5)(5,6)...(5,n) 是必胜局面，</span><br><span class="line">(4,7) 是必败局面；	(4,4)(4,5)(4,6)</span><br><span class="line">					(4,8)(4,8)(4,9)...(4,n)</span><br><span class="line">					(7,7)(7,8)(7,9)...(7,n) 是必胜局面，</span><br><span class="line">(6,10) 是必败局面；	(6,6)(6,7)(6,8)(6,9)</span><br><span class="line">					(6,11)(6,12)(6,13)...(6,n)</span><br><span class="line">					(10,10)(10,11)(10,12)...(10,n) 是必胜局面。</span><br></pre></td></tr></tbody></table></figure><p></p><p>规律：（必败局面的规律比较容易找到）<br>ak 是前面必败局未出现的数中最小者，<br>bk = ak + k (k = 0,1,2,3,…n)</p><p>必败局（奇异局）的重要性质：1,2,…,n 中每一个自然数，出现且只出现在一个奇异局中。</p><p>推导：</p><ol><li>由于 ak 总是选择未出现的数，所以每个数总能出现在奇异局中且 ak 不会选择到重复的数。</li><li>bk = ak + k，所以 bk 总是比前面所有奇异局出现的数都大，所以 bk 不会选择到重复的数。</li></ol><p>必胜方的策略是：始终让对手面对必败局（奇异局）。</p><p>给定任意局势 (a,b)，判定 (a,b) 是否为必败局的方法：k = 0,1…n，黄金比例 φ = 1.618033，ak = [φ <em>k]，bk = ak + k = [φ^2</em> k]。<br>比如：<br>k = 0，ak = 0，bk = 0<br>k = 1，ak = 1，bk = 2<br>k = 2，ak = 3，bk = 5<br>k = 3，ak = 4，bk = 7</p><p>更好的一种判断策略：k = bk - ak，当 ak == [φ * k] 时，为奇异局。</p><p>从胜负概率角度，如果堆中数量随机，先手一方优势很大。</p><h1 id="组合游戏-SG-函数和-SG-定理"><a href="#组合游戏-SG-函数和-SG-定理" class="headerlink" title="组合游戏 - SG 函数和 SG 定理"></a>组合游戏 - SG 函数和 SG 定理</h1><h2 id="必胜点与必败点"><a href="#必胜点与必败点" class="headerlink" title="必胜点与必败点"></a>必胜点与必败点</h2><p>必胜点和必败点的概念：<br>P 点（Previous player）：必败点，换而言之，就是谁处于此位置，则在双方操作正确的情况下必败。<br>N 点（Next player）：必胜点，处于此情况下，双方操作均正确的情况下必胜。</p><p>必胜点和必败点的性质：</p><ol><li>所有终结点是必败点 P。</li><li>从任何必胜点 N 操作，至少有一种方式可以进入必败点 P。</li><li>无论如何操作，必败点 P 都只能进入必胜点 N。</li></ol><p>通常我们分析必胜点和必败点都是以终结点进行逆序分析。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1847" target="_blank" rel="noopener">HDU 1847 Good Luck in CET-4 Everybody!</a></p><p>打牌的规则：</p><ol><li>总共 n 张牌;</li><li>双方轮流抓牌；</li><li>每人每次抓牌的个数只能是2的幂次（即：1，2，4，8，16…）；</li><li>抓完牌，胜负结果也出来了：最后抓完牌的人为胜者。</li></ol><p>假设 Kiki 和 Cici 都足够聪明，并且每次都是Kiki先抓牌，请问谁能赢呢？</p><p>分析：<br>当 n = 0 时，显然为必败点，因为此时你已经无法进行操作了。<br>当 n = 1 时，因为你一次就可以拿完所有牌，故此时为必胜点。<br>当 n = 2 时，也是一次就可以拿完，故此时为必胜点。<br>当 n = 3 时，要么剩 1 张要么剩 2 张，无论怎么取对方都将面对必胜点，故这一点为必败点。</p><p>以此类推：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 ...</span><br><span class="line">P N N P N N P ...</span><br></pre></td></tr></tbody></table></figure><p></p><p>你发现了什么没有，对，他们就是成有规律，使用了 P/N 来分析，有没有觉得问题变简单了。</p><h2 id="SG-函数和-SG-定理"><a href="#SG-函数和-SG-定理" class="headerlink" title="SG 函数和 SG 定理"></a>SG 函数和 SG 定理</h2><p>组合游戏的和通常是很复杂的，但是有一种新工具，可以使组合问题变得简单 ———— SG 函数和 SG 定理。</p><p>Sprague-Grundy 定理：</p><p>游戏和的 SG 函数等于各个游戏 SG 函数的 Nim 和。这样就可以将每一个子游戏分而治之，从而简化了问题。而 Bouton 定理就是 Sprague-Grundy 定理在 Nim 游戏中的直接应用，因为单堆的 Nim 游戏 SG 函数满足 SG(x) = x。</p><p>Sprague-Grundy 函数：</p><p>首先定义 mex(minimal excludant) 运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。比如，mex{0, 1, 2, 4} = 3、mex{2, 3, 5} = 0、mex{} = 0。</p><p>对于任意状态 i，定义 SG(x) = mex(S)，其中 S 是 i 后继状态的 SG 函数值的集合。如 i 有三个后继状态分别为 SG(a)、SG(b)、SG(c)，那么 SG(i) = mex{SG(a), SG(b), SG(c)}。这样集合 S 的终态必然是空集，所以 SG 函数的终态为 SG(i) = 0，当且仅当 i 为必败点 P 时。</p><h2 id="取石子问题"><a href="#取石子问题" class="headerlink" title="取石子问题"></a>取石子问题</h2><p>有 1 堆 n 个的石子，每次只能取{1, 3, 4}个石子，先取完石子者胜利，那么各个数的 SG 值为多少？</p><p>SG[0] = 0，f[] = {1, 3, 4}</p><p>i = 1，可以取走 1 - f{1} 个石子，剩余 {0} 个，SG[1] = mex{SG[0]} = mex{0} = 1;<br>i = 2，可以取走 2 - f{1} 个石子，剩余 {1} 个，SG[2] = mex{SG[1]} = mex{1} = 0;<br>i = 3，可以取走 3 - f{1, 3} 个石子，剩余 {2, 0} 个，SG[3] = mex{SG[2], SG[0]} = mex{0, 0} =1;<br>i = 4，可以取走 4 - f{1, 3, 4} 个石子，剩余 {3, 1, 0} 个，SG[4] = mex{SG[3], SG[1], SG[0]} = mex{1, 1, 0} = 2;<br>i = 5，可以取走 5 - f{1, 3, 4} 个石子，剩余 {4, 2, 1} 个，SG[5] = mex{SG[4], SG[2], SG[1]} = mex{2, 0, 1} = 3;</p><p>以此类推…..</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i     0 1 2 3 4 5 6 7 8....</span><br><span class="line">SG[i] 0 1 0 1 2 3 2 0 1....</span><br></pre></td></tr></tbody></table></figure><p>由上例我们就可以得到 SG 函数值求解步骤：</p><ol><li>使用数组 f 将可改变当前状态的方式记录下来。</li><li>使用另一个数组将当前状态 i 的后继状态标记。</li><li>最后模拟 mex 运算，在标记值中搜索未被标记值的最小值，将其赋值给 SG(i)。</li><li>不断重复 2~3 步，知道计算完 1~n 的函数值。</li></ol><h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可改变当前状态的方式，N为方式的种类</span></span><br><span class="line"><span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前状态 i 的后继状态的集合</span></span><br><span class="line"><span class="keyword">boolean</span>[] isVisit = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0~n的SG函数值</span></span><br><span class="line"><span class="keyword">int</span>[] SG = <span class="keyword">new</span> <span class="keyword">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSG</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为SG[0]始终等于0，所以i从1开始</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 每一次都要将上一状态的后继集合重置</span></span><br><span class="line">		Arrays.fill(isVisit, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N &amp;&amp; f[j] &lt;= i; j++) {</span><br><span class="line">			<span class="comment">// 将后继状态的SG函数值进行标记</span></span><br><span class="line">			isVisit[SG[i - f[j]]] = <span class="keyword">true</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;; j++) {</span><br><span class="line">			<span class="comment">// 查询当前后继状态SG值中最小的非零值</span></span><br><span class="line">			<span class="keyword">if</span> (!isVisit[j]) {</span><br><span class="line">				SG[i] = j;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1848" target="_blank" rel="noopener">HDU 1848 Fibonacci again and again</a></p><p>任何一个大学生对菲波那契数列(Fibonacci numbers)应该都不会陌生，它是这样定义的：<br>F(1)=1;<br>F(2)=2;<br>F(n)=F(n-1)+F(n-2)(n&gt;=3);<br>所以，1,2,3,5,8,13……就是菲波那契数列。</p><p>在HDOJ上有不少相关的题目，比如1005 Fibonacci again就是曾经的浙江省赛题。</p><p>今天，又一个关于Fibonacci的题目出现了，它是一个小游戏，定义如下：<br>1、这是一个二人游戏;<br>2、一共有3堆石子，数量分别是m, n, p个；<br>3、两人轮流走;<br>4、可以选择任意一堆石子，然后取走f个；<br>5、f只能是菲波那契数列中的元素（即每次只能取1，2，3，5，8…等数量）；<br>6、最先取光所有石子的人为胜者；</p><p>假设双方都使用最优策略，请判断先手的人会赢还是后手的人会赢。</p><p>Input<br>输入数据包含多个测试用例，每个测试用例占一行，包含3个整数m,n,p（1&lt;=m,n,p&lt;=1000）。<br>m=n=p=0则表示输入结束。</p><p>Output<br>如果先手的人能赢，请输出“Fibo”，否则请输出“Nacci”，每个实例的输出占一行。</p><p>Sample Input<br>1 1 1<br>1 4 1<br>0 0 0</p><p>Sample Output<br>Fibo<br>Nacci</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> MAXN = <span class="number">1001</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">16</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">boolean</span>[] isVisit = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAXN];</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span>[] SG = <span class="keyword">new</span> <span class="keyword">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">		StreamTokenizer in = <span class="keyword">new</span> StreamTokenizer(<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)));</span><br><span class="line">		PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">		getFibonacci();</span><br><span class="line">		getSG(MAXN);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> m, n, p;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">			in.nextToken();</span><br><span class="line">			m = (<span class="keyword">int</span>) in.nval;</span><br><span class="line">			in.nextToken();</span><br><span class="line">			n = (<span class="keyword">int</span>) in.nval;</span><br><span class="line">			in.nextToken();</span><br><span class="line">			p = (<span class="keyword">int</span>) in.nval;</span><br><span class="line">			<span class="keyword">if</span> (m == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span> &amp;&amp; p == <span class="number">0</span>) {</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">			out.println((SG[n] ^ SG[m] ^ SG[p]) != <span class="number">0</span> ? <span class="string">"Fibo"</span> : <span class="string">"Nacci"</span>);</span><br><span class="line">		}</span><br><span class="line">		out.flush();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFibonacci</span><span class="params">()</span> </span>{</span><br><span class="line">		f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) {</span><br><span class="line">			f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getSG</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">			Arrays.fill(isVisit, <span class="keyword">false</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N &amp;&amp; f[j] &lt;= i; j++) {</span><br><span class="line">				isVisit[SG[i - f[j]]] = <span class="keyword">true</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;; j++) {</span><br><span class="line">				<span class="keyword">if</span> (!isVisit[j]) {</span><br><span class="line">					SG[i] = j;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>','2018-05-01 11:25:00');
INSERT INTO `note` VALUES (4,2,'《Java 8 函数式编程》笔记1','<h1 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h1><p>在图书馆找有关 <code>Java</code> 的书时发现了这本动物出版社的书，大一时就听过 <code>lambda</code>，匿名函数之类的了（虽然两者不同），一直没机会接触前者，鉴于前段时间写的程序有好多匿名函数，很是冗余，本着好奇以及打算重构的心，就借来这本书打算学习一遍 <code>lambda</code>。本笔记按照章节顺序从第 2 章开始。</p><p>纸质书读起来很有滋味，建议买来或借来品味一番。</p><p>随书的资料在作者的 <a href="https://github.com/RichardWarburton/java-8-lambdas-exercises" target="_blank" rel="noopener">github</a> 中可以下载到。</p><p>本笔记代码也全部放在 <a href="https://github.com/Zoctan/Java-8-Lambdas/tree/master" target="_blank" rel="noopener">github</a> 中，建议搭配代码食用~</p><h1 id="设置断言"><a href="#设置断言" class="headerlink" title="设置断言"></a>设置断言</h1><p><code>Idea</code> 和 <code>Eclipse</code> 都是默认不开启断言的，请先设置好。</p><h1 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h1><h2 id="第一行-lambda"><a href="#第一行-lambda" class="headerlink" title="第一行 lambda"></a>第一行 lambda</h2><p>使用匿名类将按钮和点击行为关联起来：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">button.addActionListener(<span class="keyword">new</span> ActionListener() {</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"clicked"</span>);</span><br><span class="line">	}</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>使用 <code>lambda</code> 表达式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.addActionListener(event -&gt; System.out.println(<span class="string">"clicked"</span>));</span><br></pre></td></tr></tbody></table></figure><p>匿名类：</p><ul><li>方法参数类型需要显式声明：<code>ActionEvent event</code></li></ul><p>lambda：</p><ul><li>无需指定类型，<code>javac</code> 根据上下文推断出 <code>event</code> 的类型（<code>addActionListener</code> 方法的签名）</li></ul><p>注：</p><ol><li><code>lambda</code> 声明参数时也可以包括参数类型（比如：(int x, int y) -&gt; x + y）；</li><li>有时编译器不一定能根据上下文推断出参数类型，这时要显示声明。</li></ol><p><code>lambda</code> 表达式的不同形式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该 Runnable 接口只有 1 个 void run() 方法</span></span><br><span class="line"><span class="comment">// 使用空括号 () 表示没有参数</span></span><br><span class="line">Runnable noArguments = () -&gt; System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有 1 个参数，可省略括号</span></span><br><span class="line">ActionListener oneArgument = event -&gt; System.out.println(<span class="string">"clicked"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda 主体不仅可以是表达式，也可以是一段代码块</span></span><br><span class="line"><span class="comment">// 用大括号 {} 括起来的代码块</span></span><br><span class="line"><span class="comment">// 遵循的规则和普通方法一样</span></span><br><span class="line">Runnable multiStatement = () -&gt; {</span><br><span class="line">	System.out.println(<span class="string">"Hello 1"</span>);</span><br><span class="line">	System.out.println(<span class="string">"Hello 2"</span>);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式声明参数类型</span></span><br><span class="line">BinaryOperator&lt;Integer&gt; addExplicitType = (Integer x, Integer y) -&gt; x + y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码是创建一个函数，用来计算出两个数字相加的结果</span></span><br><span class="line"><span class="comment">// add 不是两个数字的和，而是将两个数字相加的那行代码</span></span><br><span class="line">BinaryOperator&lt;Integer&gt; add = (x, y) -&gt; x + y;</span><br><span class="line">System.out.println(add.apply(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></tbody></table></figure><h2 id="引用值，而不是变量"><a href="#引用值，而不是变量" class="headerlink" title="引用值，而不是变量"></a>引用值，而不是变量</h2><p>匿名类中使用所在方法的变量时需要 <code>final</code> 修饰：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String username = getUsername();</span><br><span class="line"></span><br><span class="line">button.addActionListener(<span class="keyword">new</span> ActionListener() {</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span>{</span><br><span class="line">		System.out.println(username + <span class="string">" clicked"</span>);</span><br><span class="line">	}</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p><code>lambda</code> 表达式中使用时虽然可以没有 <code>final</code> 修饰符，但实际上仍是 <code>final</code> 变量：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String username = getUsername();</span><br><span class="line"></span><br><span class="line">button.addActionListener(event -&gt; System.out.println(username + <span class="string">" clicked"</span>));</span><br></pre></td></tr></tbody></table></figure><p>使用 <code>final</code> 变量，实际上就是使用赋给该变量的一个特定值。</p><h2 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h2><p>函数接口：只有 1 个抽象方法的接口，用作 <code>lambda</code> 表达式的类型。</p><p>比如 <code>ActionListener</code> 接口：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ActionListener extends EventListener {</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>该单一抽象方法的命名并不重要，只要方法签名和 <code>lambda</code> 表达式的类型匹配即可。</p><p>一些最重要的函数接口：</p><table><thead><tr><th style="text-align:center">接口</th><th style="text-align:center">参数</th><th style="text-align:left">返回类型</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center">Predicate<t></t></td><td style="text-align:center">T</td><td style="text-align:left">boolean</td><td style="text-align:center">这张唱片发行了吗</td></tr><tr><td style="text-align:center">Consumer<t></t></td><td style="text-align:center">T</td><td style="text-align:left">void</td><td style="text-align:center">输出一个值</td></tr><tr><td style="text-align:center">Function<t ,="" r=""></t></td><td style="text-align:center">T</td><td style="text-align:left">R</td><td style="text-align:center">获得 A 对象的名字</td></tr><tr><td style="text-align:center">Supplier<t></t></td><td style="text-align:center">None</td><td style="text-align:left">T</td><td style="text-align:center">工厂方法</td></tr><tr><td style="text-align:center">UnaryOperator<t></t></td><td style="text-align:center">T</td><td style="text-align:left">T</td><td style="text-align:center">逻辑非(!)</td></tr><tr><td style="text-align:center">BinaryOperator<t></t></td><td style="text-align:center">(T,T)</td><td style="text-align:left">T</td><td style="text-align:center">求两个数的和(+)</td></tr></tbody></table>','2018-05-01 07:13:00');
/*!40000 ALTER TABLE `note` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2018-05-18 12:11:43
